# LeetCode ( lang: JavaScript <img src="https://github.com/lymphoidcell/leetcode_in_js/blob/main/JavaScript-logo.png" alt="JavaScript Logo" width="20" height="20"> )

Roadmap via https://neetcode.io/roadmap

## Section 1: Arrays & Hashing
__About__
1. Basics of arrays and how to manipulate them.
2. Introduction to hashing and its applications for fast data retrieval.

#### MORE:
* __Real-life Example__ : In a database, hashing is used to create indexes for quick data retrieval based on a certain key. This improves the efficiency of searching for records.

* __Usage Example__ : Given an array of integers, find two numbers such that they add up to a specific target. You can use hashing to efficiently check if the complement of the current number exists in the array.

## Section 2: Stack
__About__
1. Understanding the stack data structure and its applications.
2. Implementing a stack and solving problems using it.

#### MORE:
* __Real-life Example__ : A stack is often used to keep track of user actions, allowing them to undo operations step by step.

* __Usage Example__ : Implement a function to check if a given string of parentheses is balanced. You can use a stack to keep track of the opening and closing brackets.

## Section 3: Two Pointers
__About__
1. Techniques involving two pointers to solve problems efficiently.

#### MORE:
* __Real-life Example__ : Two pointers can be used to efficiently track the positions of two vehicles in a fleet, optimizing routes and reducing travel time.

* __Usage Example__ : Given a sorted array, find two numbers that sum to a specific target. Use two pointers starting from both ends, moving towards the center to efficiently find the pair.


## Section 4: Binary Search
__About__
1. Understanding the binary search algorithm and its applications.
2. Solving problems related to searching and optimization using binary search.

#### MORE:
* __Real-life Example__ : When looking for a contact in a sorted phonebook, binary search can be applied to quickly locate the contact's position.

* __Usage Example__ : Given a sorted array, implement a function to perform binary search to find the index of a target element.

## Section 5: Sliding Window
__About__
1. Introduction to the sliding window technique for efficiently processing arrays or lists.

#### MORE:
* __Real-life Example__ : When analyzing temperature trends over a period, a sliding window can be used to efficiently compute average temperatures and identify patterns.

* __Usage Example__ : Find the maximum sum of a subarray of a fixed size k in a given array. Use the sliding window technique to efficiently compute the sum as you move through the array.

## Section 6: Linked List
__About__
1. Basics of linked lists, types, and operations.
2. Solving problems related to linked lists.

#### MORE:
* __Real-life Example__ : Each car is a node in a linked list, and operations like adding or removing a car are efficiently handled by updating the links.
* __Usage Example__ : Implement a function to reverse a linked list. Traverse the list, reversing the links between nodes.

## Section 7: Trees
__About__
1. Understanding tree data structures (binary trees, binary search trees, etc.).
2. Tree traversal algorithms and related problem-solving.

#### MORE:
* __Real-life Example__ : In a company, a tree structure can represent the organizational hierarchy, with each node representing an employee and their position in the company.
* __Usage Example__ : Given a binary tree, implement a function to perform an in-order traversal, printing the values of nodes in ascending order.

## Section 8: Tries
__About__
1. Understanding trie data structures and their applications, especially in string-related problems.

#### MORE:
* __Real-life Example__ : Tries are commonly used to store and efficiently retrieve word suggestions in autocomplete features, like those in search engines or messaging applications.
* __Usage Example__ : Implement a spell-checker using a trie to efficiently check if a given word is in the dictionary.

## Section 9: Backtracking
__About__
1. Introduction to backtracking and solving problems with recursive algorithms.

#### MORE:
* __Real-life Example__ : Backtracking is often employed to solve complex puzzles like Sudoku, exploring different possibilities until a solution is found.
* __Usage Example__ : Solve the N-Queens problem where you need to place N queens on an NÃ—N chessboard such that no two queens threaten each other.

## Section 10: Graphs
__About__
1. Basics of graphs, types, and representations.
2. Graph traversal algorithms (DFS, BFS) and problem-solving.

#### MORE:
* __Real-life Example__ : Graphs model relationships, and social networks use graph algorithms to find connections, recommend friends, and analyze the structure of the network.
* __Usage Example__ : Find the shortest path between two nodes in a weighted graph. Use Dijkstra's algorithm to efficiently find the shortest path.

## Section 11: 1D-Dynamic Programming
__About__
1. Introduction to dynamic programming with problems involving a single dimension.

#### MORE:
* __Real-life Example__ : Dynamic programming can be used to find the best time to buy or sell stocks, maximizing profit over time.
* __Usage Example__ : Given an array of integers, find the maximum subarray sum using dynamic programming to keep track of the maximum sum.

## Section 12: Heap / Priority Queue
__About__
1. Understanding the heap data structure and its applications.
2. Solving problems efficiently using priority queues.

#### MORE:
* __Real-life Example__ : Priority queues can be used to efficiently schedule tasks based on their priority, ensuring that higher-priority tasks are executed first.
* __Usage Example__ : Implement a priority queue to efficiently find and process the maximum or minimum element in a collection.

## Section 13: Intervals
__About__
1. Handling problems involving intervals in data.

#### MORE:
* __Real-life Example__ : When scheduling appointments or events, intervals can be used to represent time slots and identify overlapping or available time periods.
* __Usage Example__ : Given a collection of intervals, merge overlapping intervals to simplify the representation.

## Section 14: Greedy
__About__
1. Understanding greedy algorithms and solving problems using them.

#### MORE:
* __Real-life Example__ : Greedy algorithms are used in data compression, like Huffman coding, where the most frequent symbols are assigned shorter codes to optimize overall compression.
* __Usage Example__ : Implement a function to make change using the fewest coins, selecting the largest coin denomination at each step.

## Section 15: Advanced Graphs
__About__
1. Advanced graph algorithms (Dijkstra's, Bellman-Ford, etc.).
2. Solving complex graph problems.

#### MORE:
* __Real-life Example__ : Advanced graph algorithms are used to find the shortest and fastest routes in navigation systems, considering real-time traffic conditions.
* __Usage Example__ : Solve the minimum spanning tree problem using Kruskal's algorithm.

## Section 16: 2D-Dynamic Programming
__About__
1. Extending dynamic programming to problems involving two dimensions.

#### MORE:
* __Real-life Example__ : Dynamic programming is applied to compare and match patterns in images, contributing to image recognition and computer vision.
* __Usage Example__ : Solve the longest common subsequence problem between two strings using dynamic programming.

## Section 17: Bit Manipulation
__About__
1. Understanding bitwise operations and solving problems using bit manipulation.

#### MORE:
* __Real-life Example__ : Bit manipulation is often used in the implementation of network protocols to efficiently encode and decode data.
* __Usage Example__ : Swap two numbers without using a temporary variable using bitwise XOR operations.

## Section 18: Math and Geometry
__About__
1. Applying mathematical and geometric concepts to problem-solving.

#### MORE:
* __Real-life Example__ : Math and geometry are fundamental in computer graphics for tasks like rendering 3D scenes, transforming objects, and calculating lighting effects.
* __Usage Example__ : Implement a function to check if three points in a 2D plane are collinear, using cross-product or slope comparisons.
